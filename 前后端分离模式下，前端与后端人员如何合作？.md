# 前后端分离模式下，前端与后端人员如何合作？ #

### 为什么写这篇文章？ ###

在致远公司一月有余，说实话，这是我做前端开发几年来，最痛苦的一次开发经历。

目前我们公司采用了近几年比较火的前端技术Vue和前后端分离架构模式（目前是非完全分离架构）。但是，很明显，我们在这方面的实践还缺乏经验和思考。

目前，最大的问题出现在前后端合作以及所谓的“联调”上。下面举例说一些我遇到的问题：

- 开发之初，我并不知道知道服务端会返回什么样的数据，比如数据结构，参数名称等等。这些东西，我都需要自己去假想，自己定义一个结构、参数名称和字段值，然后自己去手动写这些假数据。实际上这个过程，非常耗费时间，而且没有任何意义。因为这些假数据最终会被完全移除没有任何用处，但是，我们要耗费时间自己写这些数据。

- 写了假数据之后，就带来了另外一个问题，代码中充斥了大量的难看的mock数据使用方式。然后，后端人员把真正的接口完成之后，才发现自己的假数据，参数名对不上，数据结构不对导致解析逻辑有问题。然后又要耗费时间，去检查我们的代码，修改已经写好的代码，让参数和数据结构对应上。这时候，我们还是没法请求接口，我要在本地继续开发，只有再把假数据也跟着修改一遍。

- 但是，事情还没完。这时候，我们还是没法请求接口，并不能保证我手动敲的这些代码完全正确，有没有参数或者字段名写错，也并不知道请求能否真正成功。这就出现了所谓的“联调”阶段。

- 在联调开始时，我发现接口请求的封装有问题，并不能POST数据。因为之前，我们并没有发起过一次真正请求，不知道这个请求的封装有问题，后面解决这个问题，又花费了半天时间。但是，这个问题完全不应该在联调阶段才被发现。所以，在项目一开始我就建议，把这部分代码提取出来，所幸改动并不大。但是，值得思考的是，这种问题需要等到联调才能发现吗？万一一些经验不足开发的按照错误方式写了很多代码，那到了联调时候才发现，岂不是灾难？

- 从解决这个问题开始，就出现了最让人抓狂的时候--联调。

- 首先，我必须要把我的前端代码放在后端服务容器中运行，才能看到我的URL有没有写错，参数有没有传正确，返回的数据结构有没有正确解析，业务逻辑方面是否正确。因为这些东西都只有在真正发起请求的情况下才能验证。而这其实已经违背前后端分离的热驱动思想--前后端职责分离，不成为互相的阻塞点。

- 由于前一个问题：必须放在服务器中运行，所以前端的一个修改或者修复，必须传递给后端，等待他更新部署完成才能看到修改的结果，导致开发效率大大降低。就有了这样一个过程，前端修改代码-->前端打包代码-->上传SVN-->等待后端从SVN更新-->后端部署-->等待部署生效-->前端验证问题-->前端再修改，这个过程非常冗长和漫长，有时候等待后端部署生效要等好几分钟，我就只有一遍一遍的刷新等待生效，别给我说什么前端缓存，我做了几年前端还不懂清缓存？这让一个强迫症选手真的很抓狂。

- 想一想，我们在上面这个过程中，实际上是很耗费时间和精力的。比如，遇到后端人员不在座位上，而你又急着调试怎么办？又比如后端正专心的攻克一个难题，然后我突然去打扰他，让他重新更新部署，这就打断了他的思路，然后过一会又去打扰一遍，任谁也会挺烦的。而且，现在的情况是，即使后端及时更新了，但是我前端并不能第一时间看到结果，然后就出现了这个一种对话：

- 握草，怎么没反应啊？你是不是没更新上啊？你清缓存了吗？清除了啊？你肯定没清干净，我看看，咦，特么的怎么没反应啊，我明明更新了的啊，你等一会儿看看嘛。。。。我能说我很崩溃吗

- 这里还有另外一个问题，就是后端人员提供API接口的方式，首先，后端人员需要手动的完成API文档接口，然后把这个text格式的文档发送给我。这里又有一个过程：后端人员需要要去浏览他的代码，然后一个一个手动的去写接口定义，参数名称，数据结构形式-->上传SVN-->前端更新SVN，接受到接口文档-->按照接口改好了之后，执行上面的联调过程-->发现接口不对-->经过排查，是接口文档写错了-->更新文档-->重新更改代码-->再次联调验证。

- 我相信任谁也能看出来，上面这两个过程，是非常的低效。

- 再者就是调试不便问题。我们确实可以通过浏览器的debug功能来调试代码，查看错误。但是，如果有些代码不能打断点怎么办？别给我说什么我打断点的方式不对，不信你来试试。还有，我们不能监测到数据状态的变更过程，当断点走到某一步，我们需要知道前面步骤时它的数据状态是怎么样时，怎么办？难道再倒回去，重新走一遍？我发现了一个错误，还不能直接修改，不能直接保存然后看到结果（因为是打包编译后的代码），我需要在我本地修改了，然后重复上面的联调过程。

	> 这种调试方式，违背了新技术架构模式下的前端开发思想：热重载、热更新、数据状态管理

- 还有一个问题，前端人员在本地开发时，需要切换到mock数据形式，因为没有数据你怎么看到效果？然后，联调时，为了避免这些mock数据的影响，又需要清除或者注释掉这些代码。这种过程也很麻烦，虽然可以通过环境变量来判断，但是，你的代码中必然充斥着大量的条件判断，和丑陋的最终无用的mock数据。

- 最终，好不容易调试的正确了，然后到了快要演示效果的时候，后端告诉我，接口有新的更新。好吧，我又欲哭无泪的把上面的过程再次重复一遍。

上面这些问题只是一些比较明显的问题，而且这些只是我们在开发阶段的问题，还不涉及打包部署、后期维护等方面。

其实，这些都是因为，我们在实施前后端分离时，并没有在开发模式上做出相应的改变，来适应这种架构。

### 关于前后端分离 ###

什么是前后端分离以及它的架构模式，我在这里不详谈。我前面已经说过，我们现在是不完全的前后端分离，但是，确确实实已经有了前后端分离的模式。

前后端分离的目的，是前后端职责分离，不互相依赖，不互相阻塞，并行开发，前后端仅仅通过restful风格的接口交换json形式的数据即可（这里可能除了需要做服务端的首屏渲染需要服务端支持）。

前后端分离后，前端就有了一些新的概念和要求：组件化、工程化、自动化、热驱动、热更新、热部署。

要达到这些目的，首先我们在开发模式上，就要做出一些改变，其中最重要的一个点，就是前后端如何合作问题。

> 这里我没有过多的解释前后端分离的概念和架构形式，我相信大多数玩家都知道，这里我主要讨论前后端分离后，前端人员和后端人员如何合作问题。

### 关于API接口设计 ###

前后端分离模式下，要求前端和后端人员并行开发，前端不必等后端接口完全可用才开始开发。那前端又要做出实际的效果来怎么办？答案很简单，假数据！

但是，前面已经说过，前端写假数据，一是前端的假数据并不能与最终和后端写的接口的参数名和数据结构对应上，二是手动写假数据太麻烦。

首先，我们来解决第一个问题，怎么才能保证前端的假数据和后端的真接口对应上，以降低前端需要重新修改代码的成本。

那么，我们可以想到，在真正开始开发之前，就做好API接口的设计与定义，包括需要哪些接口，请求方式，接口地址，参数名称，数据结构等等。然后前端和后端都按照这个约定来开发，那么我们是不是就可以解决第一个问题。最终，即使有一些调整，那么也只是一些小的调整。

这里我们可以分析一下，在开发之初做API接口设计的好处：

1. 首先在开发之初做API接口设计，我们可以进一步梳理业务逻辑，让我们对整个业务逻辑和功能需求有更清晰的认识。甚至会在心里形成一种这个产品最终形态的样子出来。
2. 在梳理接口的过程中，我们能更早的暴露一些问题出来。比如，我们会分析会需要多少接口，哪些接口可以做合并和拆分（主要提高性能），这些接口需要的数据源能不能获取到，接口功能的依赖能不能满足要求等等问题。
3. 有了梳理和设计后的API接口，后端开始开发时，就已经有了明确的目标和方向，他不用再去分析其中的业务逻辑，完全可以按照设计的接口快速的开发。
4. 有了设计后的接口定义，就有了约定。前后端按照统一的约定，会大大的降低修改和维护的成本。
5. 对于测试人员，也有了测试依据。可以根据接口设计来写自动化测试脚本。

这里，又有另外一个问题，谁来做这个API接口的设计。前端？还是后端？既然是约定，那么肯定会涉及多方人员，才能形成约定。

关于API接口设计，需要三方人员的参与：架构设计师、前端开发和后端开发。

在设计阶段，架构师需要将项目整体进行分析，确定API风格，数据交互形式，人员配备，职责分配，协作模式等等内容。同时，架构师需要对整个API接口有高度的清晰的认识。然后由前端和后端人员，共同讨论确定API接口定义，并出具设计好的接口文档，最终再有架构师进行确认方案是否可行。

这里，还有一个问题，怎么做接口文档？还有，怎么管理API接口？

### 如何管理API ###

首先，我们需要达成以下目标：

1. 要直观，要有良好的接口定义形式，能够一眼就看明白；
2. 然后，需要人工去手动完成的部分，尽可能的少，降低文档维护成本；
3. 提供在线浏览模式，减少文件传递过程，必要时也可以导出为文档；
4. 接口可测试；
5. 能够自动生成mock数据；
6. 能够做版本管理。

完成上面这些目标，这里我推荐几款开源工具：Swagger和阿里的RAP。这两款工具，均是开源，可以直接部署在公司内网。

其中swagger长这样：![](http://i.imgur.com/BHWvaso.png)

> 关于如何部署和使用我这里不再介绍，可以在网上查找资料，或者参考我另外一篇很早之前的文章《swagger_UI入门》。这里还有其他一些在线API管理工具，我们可以搭配使用，这里不再列举，这里只是提出解决思路。

有了这些工具，我们可以直接在UI界面上，进行API接口的设计定义。而且，他们都可以生成在线的API接口文档；提供直观的接口展现形式；均可以在线直接测试接口；还可以直接根据定义的接口，生成一个mock服务器，前端可以直接请求mock服务器，拿到mock数据。

关于swagger和RAP我这里做一下简单的比较：

1. 在接口设计阶段，swagger需要使用例如sosoapi来在线编辑，然后导出为swagger能识别的json文件形式，或者直接编辑json（Yaml）文件。而RAP本身就带有在线编辑器。
2. 在接口设计完成后，前端和后端都需要按照设计来开发。
3. 并且swagger和RAP都可以集成到后端代码中。但是，swagger可以通过注解来识别接口方法，再反向实时生成一个swagger UI的接口文档。然后这个接口文档也具有之前的那些所有特性，但是他能根据后台代码的修改自动更新文档。RAP的设计完成后，后端代码可以根据这个设计来对自己的代码做单元测试，它更强调的是强制检测后端代码是否符合设计，而不能反向生成文档。
4. swagger的学习曲线更高，能供开发人员、测试人员、客户等等共同使用。RAP更加强调设计和检验设计，只能供开发人员自测。

### 关于mock数据 ###

其实上面这些工具已经解决了mock数据的问题。

在使用这些工具设计API的时候，我们可以根据mock.js的语法，来设计返回结果的数据结构，包括字段名，字段值的规则。然后生成一个mock服务器，前端可以直接请求这个mock服务器，然后返回根据mock规则生成的假数据。可以说，这个时候，mock服务器就已经相当于后台服务器了（只是这里没有验权，没有真实数据库里的数据）。

现在，我们不用再手动写mock数据了；前端代码非常干净，没有多余的无效代码；我们能发起真实的请求了，也能提前避免封装的请求方式不能post数据问题了；前端代码中的字段名和数据结构，解析方式，也是正确的了；也能正确编写真实情况下的交互逻辑了；我们可以针对接口进行测试了，不用再担心接口不通了。

按照这个模式开发，前端写出来的代码已经非常接近最终的形式。甚至于，可以消除“联调”阶段，直接进入组内自测与测试验证阶段。

### 如何简化前后端联调 ###

好，下面解决另外一个前后端联调的问题。

首先，我们这里要明确一个定义，这里的前后端联调，指的是开发阶段前端和后端互相验证的过程，而不是发布测试环境，供组内自测或者测试验证的阶段。那么，联调就发生在前端本地与后端本地之间。

既然，是开发阶段发生在前端本地与后端本地之间的事情，那么我们肯定希望简化两者之间的过程：

1. 前端本地启动一个nodejs开发服务，然后前端能直接访问后端本地的服务
2. 前端修改能直接在本地看到效果，方便调试
3. 后端接口修改后，前端也能及时访问修改后的结果（必须要重启服务器才能生效的情况例外）

> 简化后的过程，会省略很多步骤与时间：没有前端打包过程；没有前端传送给后端的过程；没有后端部署的过程；没有后端缓存生效的时间。

但是，前面已经说过，我们现在是不完全的前后端分离模式，前端代码还需要部署在与后端代码同一台服务器上运行。如果我们要实现上面的简化开发过程，这里有两个问题需要解决：1.验权问题，怎么验权？2.跨域问题

验权问题：验权其实不外乎基于cookie与session或者基于token或者jwt验证模式，我们可以在开发阶段生成一些长效的身份信息token，然后在前端请求时带上参数即可。

跨域问题：后端提供两种配置文件，一是开发时候允许跨域访问的配置文件，二是生产情况下不允许跨域的配置文件。然后，前端使用跨域请求方法即可。

> 这里，需要说明一下，我对目前我们v5 cap4的验权机制和实际架构模式不是很了解，也许解决起来没有那么轻松，但是总是有解决办法的，我们可以再商讨决定。

如果一切顺利，那么我们就没有那么繁琐的联调过程了。

### #（9.13更新）使用代理服务# ###

上面说了一种解决前后端联调麻烦的解决办法，但是需要前端和后端配合。今天，我又找到另外一种只需要在前端进行配置，就能解决跨域和验权的问题----使用代理服务。

我们知道，在前端开发环境，webpack-dev-server会启动一个nodejs的服务，这个服务是用来托管前端页面的，但是，响应接口请求的服务在后端。这里，我们可以把前端的接口请求进行拦截，然后通过代理转发到后端服务器上。

也就是说，我们在前端页面中，还是按照页面部署在后端服务器中的方式写代码，接口请求也按照正常方式发起，但是这里接口请求会被我们的nodejs服务接受。然后，然后我们部署在nodejs上的代理服务会分析这些请求，把这些请求都转发到后端服务上，这样就实现了前端和后端接口通信。

实际上，webpack-dev-server插件提供了代理服务的配置选项。我们首先在config文件夹中新建一个proxy.js文件，我这里的配置如下：

    var proxySite = 'http://10.5.5.233:8088';// 代理万翔本地
	// var proxySite = 'http://10.5.5.204:8088';// 代理测试环境
	
	module.exports = {
	    '/seeyon/rest/cap4/template/' : { // 接口请求匹配模式
	        target : proxySite, // 代理目标服务器
	        changeOrigin: true, // 允许跨域
	        headers: {
	            Accept: 'application/json' // 数据格式
	        },
	        secure: false
	    },
	    '/seeyon' : { // 打开v5首页，可进行登录，拿到session
	        target : proxySite,
	        changeOrigin: true,
	        headers: {
	            Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'
	        },
	        secure: false
	    }
	}

然后，在config/index.js文件中，将配置的代理选项配置给webpack-dev-server插件的proxy选项。

	var path = require('path')
	var proxy = require('./proxy'); // 引入代理配置选项
	
	module.exports = {
	  build: {
	    ...
	  },
	  dev: {
	    ...
	    proxyTable: proxy, // 配置给webpack-dev-server插件
	 	...
	  }
	}

然后，启动前端开发服务。打开loaclhost:8080/seeyon，就能访问后端的主页面，我们可以直接登录，然后拿到session。

然后，在前端页面中正常发起一个请求，代理服务会把请求都转发到后端，这样，我们在前端开发服务中一样能访问后端的接口。

现在，我们在前端开始时，就能彻底不依赖后端服务器了，配合前端的热更新和热重载，我们所有的修改都能即见所得，非常方便开始和调试。

### 关于工程化与自动化 ###

上面的这些探讨，如果延伸起来，其实都是工程化与自动化的其中一个环节，主要探讨前后端分离模式下前端与后端的协作问题。

关于自动化和工程化，还有很多内容可以进行讨论，例如，自动化测试，自动化构建，自动化部署，代码检查机制，版本管理机制等等问题。当然，这些内容又会涉及很多东西，后面我会再抽时间来介绍这些问题。

